import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import org.influxdb.InfluxDB;
import org.influxdb.InfluxDBFactory;
import org.influxdb.dto.Point;
import org.influxdb.dto.Query;
import org.influxdb.dto.QueryResult;

import com.mysql.jdbc.Statement;

import okhttp3.OkHttpClient;
import okhttp3.OkHttpClient.Builder;


/*
 * This Java source file was auto generated by running 'gradle buildInit --type java-library'
 * by 'krosan' at '20.04.17 13:37' with Gradle 2.14.1
 *
 * @author krosan, @date 20.04.17 13:37
 */
public class Library {
    public boolean someLibraryMethod() {
        return false;
    }
    

    final int datasize;
    final int timeoffset = 1000;
    final int randTimeBound = 1000;
    
    Library(int datasize) {
    	this.datasize = datasize;
    }
    
    public ResultSet benchmarkDB(List<RunData> in, int threads) throws Exception {
		ExecutorService ex = Executors.newFixedThreadPool(threads);

		for (RunData rd : in)
			ex.execute(rd);
		
		ex.shutdown();
		ex.awaitTermination(10000, TimeUnit.SECONDS);
		ResultSet result = new ResultSet();
		for (RunData rd : in) {
			result = result.addResult(new ResultSet(rd.getReadTime(), rd.getWriteTime(), rd.getReadTimeTime(), rd.getDeleteTime()));
		}
		return result;
    }
    
    void printResult (String resultName, ResultSet res, int threads, int rounds) {
    	System.out.println("Time "+resultName+"\t Write: " + res.writeTime/(threads*rounds) + "\t Read: " + res.readTime/(threads*rounds)+ "\t Read@Time: " + res.readTimeTime/(threads*rounds)+ "\t Delete: " + res.deleteTime/(threads*rounds));

    }
    
    public void benchmark (int rounds, int threads, int batchsize) throws Exception {
		System.out.println("Test Run with rounds:" + rounds + " Threads: " + threads + " batchsize " + batchsize + " Datasize " + datasize);
		RunData rd = new InfluxData("http://127.0.0.1:8086", "test", new ArrayList<TimedPair<String, Integer> >(), batchsize);
		rd.createDB();
		rd = new SQLData("jdbc:mysql://localhost/?user=test&password=zwjW24345Wcsad", "test", new ArrayList<TimedPair<String, Integer> >(), batchsize);
		rd.createDB();
		rd = null;
    	ResultSet influxResult = new ResultSet();
    	ResultSet sqlResult = new ResultSet();
    	for (int i = 0; i<rounds; ++i) {
    		List<RunData> in = new ArrayList<>();
    		List<RunData> sql = new ArrayList<>();
    		for (int j=0; j<threads; ++j) {
            	List<TimedPair<String, Integer> > points = generateData(100, datasize/threads, 1000000, (timeoffset*datasize)*2000);
            	in.add(new InfluxData("http://127.0.0.1:8086", "test", points, batchsize));
            	sql.add(new SQLData("jdbc:mysql://localhost/?user=test&password=zwjW24345Wcsad", "test", points, batchsize));
    		}
    		sqlResult = sqlResult.addResult(benchmarkDB(sql, threads));
    		influxResult = influxResult.addResult(benchmarkDB(in, threads));
    	}
    	printResult("InfluxDB", influxResult, threads, rounds);
    	printResult("SQL", sqlResult, threads, rounds);
		rd = new InfluxData("http://127.0.0.1:8086", "test", new ArrayList<TimedPair<String, Integer> >(), batchsize);
		rd.deleteDB();
		rd = new SQLData("jdbc:mysql://localhost/?user=test&password=zwjW24345Wcsad", "test", new ArrayList<TimedPair<String, Integer> >(), batchsize);
		rd.deleteDB();
		rd = null;
    }
    
    public List<TimedPair<String, Integer> > generateData(int nrkeys, int nrpoints, int intbound, long mainoffset) {
    	List<String> keys = new ArrayList<>();
    	List<TimedPair<String, Integer> > values = new ArrayList<>();
    	for (int i = 0; i<nrkeys; ++i)
    		keys.add(""+i);
    	Random randomGenerator = new Random();
    	long start = System.currentTimeMillis()+mainoffset;
    	for (int i = 0; i<nrpoints; ++i) {
    		values.add(new TimedPair<String, Integer>(start, keys.get(randomGenerator.nextInt(nrkeys)), randomGenerator.nextInt(intbound)));
    		start +=timeoffset;
    	}
    	return values;
    }
    
    public static void main(String[] args) throws Exception {
    	Library lib;
       	
    	int threadn = 8;
    	lib = new Library(2000);
    	lib.benchmark(1, threadn, 500);
    	
    	ArrayList<Integer> roundList = new ArrayList<>();
    	roundList.add(1);
    	roundList.add(2);
    	roundList.add(20);
    	roundList.add(200);
    	for (int rounds : roundList) {
        	lib.benchmark(rounds, threadn, 1);
        	lib.benchmark(rounds, threadn, 100);
        	lib.benchmark(rounds, threadn, 500);
    	}

    	 
	}
    
    private class ResultSet {
    	public final long readTime;
    	public final long readTimeTime;
    	public final long writeTime;
    	public final long deleteTime;
    	
    	ResultSet() {
    		readTime = 0;
    		writeTime = 0;
    		readTimeTime = 0;
    		deleteTime = 0;
    	}
    	
    	ResultSet(long readTime, long writeTime, long readTimeTime, long deleteTime) {
    		this.readTime = readTime;
    		this.writeTime = writeTime;
    		this.readTimeTime = readTimeTime;
    		this.deleteTime = deleteTime;
    	}
    	
    	ResultSet addResult(ResultSet other) {
    		return new ResultSet(this.readTime + other.readTime, this.writeTime + other.writeTime, this.readTimeTime + other.readTimeTime, this.deleteTime + other.deleteTime);
    	}
    }
    
    private class TimedPair<S , V> {
    	S first;
    	V second;
    	long timemillis;
    	
    	TimedPair(long timemillis, S first, V second) {
    		this.timemillis = timemillis;
    		this.first = first;
    		this.second = second;
    	}

    	public long getTimeMillis() {
    		return timemillis;
    	}
    	
		public S getFirst() {
			return first;
		}

		public V getSecond() {
			return second;
		}
    }
    
    interface RunData extends Runnable{
    	public void createDB() throws SQLException;
    	void deleteData() throws SQLException;
		public long getReadTime();
    	public long getReadTimeTime();
    	public long getDeleteTime();
		public void writeData() throws SQLException;
    	public long getWriteTime();
    	public void deleteDB() throws SQLException;
    	public void readData() throws SQLException;
    	public void readDataOnTime() throws SQLException;
    	
    }
    
    private class InfluxData implements RunData {
    	String dbname;
    	InfluxDB influxDB;
    	long writeTime;
    	private long readTime;
    	List<TimedPair<String, Integer> > points;
    	int batchSize;
    	long readTimeTIme;
		private long deleteTime;
    	
    	InfluxData(String url, String dbname, List<TimedPair<String, Integer> > points, int batchSize) {
			this.dbname = dbname;
			this.points = points;
			Builder builder = new OkHttpClient.Builder().readTimeout(30, TimeUnit.SECONDS).connectTimeout(30, TimeUnit.SECONDS);			influxDB = InfluxDBFactory.connect(url); //"http://172.17.0.2:8086"
			influxDB = InfluxDBFactory.connect(url, builder);
			//			influxDB = InfluxDBFactory.connect(url);
			this.batchSize = batchSize;
		}

    	public void createDB() {
        	influxDB.createDatabase(this.dbname);
    	}
    	
    	public void writeData() {
    		if (batchSize > 1)
        		influxDB.enableBatch(batchSize, 1000, TimeUnit.MICROSECONDS);
    		long start = System.currentTimeMillis();
        	for (TimedPair<String, Integer> p : points) {
        		Point point = Point.measurement("foo")
						.time(p.getTimeMillis(), TimeUnit.MILLISECONDS)
						.addField(p.getFirst(), p.getSecond())
						.build();
        		influxDB.write(dbname, "autogen", point);
        	}
        	writeTime = System.currentTimeMillis()- start;
        	influxDB.disableBatch();
        }
    	
    	public void readData() {
    		long start = System.currentTimeMillis();

    		for (TimedPair<String, Integer> p : points) {
    			Query query = new Query("SELECT * FROM \""+ p.first+"\"", dbname);
    			influxDB.query(query);
    		}
        	setReadTime(System.currentTimeMillis()- start);

    	}
    	
       	public void readDataOnTime() {
    		long start = System.currentTimeMillis();
    		Random randomGenerator = new Random();
    		for (TimedPair<String, Integer> p : points) {
    			Query query = new Query("SELECT * FROM foo Where ts>"+p.getTimeMillis()+" AND ts<"+(p.getTimeMillis()+randomGenerator.nextInt(randTimeBound)*1000), dbname);
    			influxDB.query(query);
    		}
        	readTimeTIme =(System.currentTimeMillis()- start);
    	}
       	
		@Override
		public void deleteData() {
    		long start = System.currentTimeMillis();
    		for (TimedPair<String, Integer> p : points) {
    			Query query = new Query("Delete FROM foo Where ts<"+p.getTimeMillis(), dbname);
    			influxDB.query(query);
    		}
        	deleteTime = System.currentTimeMillis()- start;
		}
    	
    	public void deleteDB() {
    		influxDB.deleteDatabase(dbname);
    		influxDB = null;
    	}

		public long getWriteTime() {
			return writeTime;
		}

		@Override
		public void run() {
			writeData();
			readData();
			readDataOnTime();
			//deleteData();
		}

		public long getReadTime() {
			return readTime;
		}

		private void setReadTime(long readTime) {
			this.readTime = readTime;
		}

		@Override
		public long getReadTimeTime() {
			return readTimeTIme;
		}

		@Override
		public long getDeleteTime() {
			return deleteTime;
		}
    }
    
    class SQLData implements RunData {
    	
    	String url; 
    	String dbname;
    	InfluxDB influxDB;
    	long writeTime;
    	List<TimedPair<String, Integer> > points;
    	Connection connect;
    	private long readTime;
    	long readTimeTIme;
    	int batchsize;
    	long deleteTime;

    	
    	public SQLData(String url, String dbname, List<TimedPair<String, Integer> > points, int batchsize) throws ClassNotFoundException, SQLException {
			this.url = url;
			this.dbname = dbname;
			this.points = points;
    		Class.forName("com.mysql.jdbc.Driver");
            // Setup the connection with the DB
            connect = DriverManager.getConnection(url);
            this.batchsize = batchsize;
		}

		@Override
		public void run() {
			try {
				writeData();
				readData();
				readDataOnTime();
				//deleteData();
			} catch (SQLException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		@Override
		public void createDB() throws SQLException {
			PreparedStatement preparedStatement = connect.prepareStatement("Create Database " + dbname);
			preparedStatement.executeUpdate();
			preparedStatement = connect.prepareStatement("Create Table " + dbname + ".test (ts TIMESTAMP, `key` VARCHAR(200), `value` INT, index (ts), index(`key`))"); // TS can not be Primary key otherwise you can not have duplicates on the key which likly happens in TS
			preparedStatement.executeUpdate();
		}

		@Override
		public void writeData() throws SQLException {
			long start = System.currentTimeMillis();
			long counter = 0;
			PreparedStatement preparedStatement = connect.prepareStatement("insert into "+dbname+".test values (?, ?, ?)");
        	for (TimedPair<String, Integer> p : points) {
    			preparedStatement.setTimestamp(1, new Timestamp(p.getTimeMillis())); //needed since sql needs an unique Primary Key
    			preparedStatement.setString(2, p.first);
    			preparedStatement.setInt(3, p.second);    			
    			//preparedStatement.executeUpdate();
    			preparedStatement.addBatch();
    			counter++;
    			if (counter%batchsize == 0) {
    				preparedStatement.executeBatch();
    			}
        	}
        	preparedStatement.executeBatch();
        	writeTime = System.currentTimeMillis()- start;
			
		}
		
		@Override
		public void deleteData() throws SQLException {
    		long start = System.currentTimeMillis();
    		for (TimedPair<String, Integer> p : points) {
    			PreparedStatement preparedStatement  = connect.prepareStatement("delete from "+dbname+".test Where ts<?");
    			preparedStatement.setTimestamp(1, new Timestamp(p.getTimeMillis()));
    			preparedStatement.executeUpdate();
    		}
        	deleteTime = System.currentTimeMillis()- start;
		}
		
		
    	public void readData() throws SQLException {
    		long start = System.currentTimeMillis();

    		for (TimedPair<String, Integer> p : points) {
    			PreparedStatement preparedStatement  = connect.prepareStatement("select * from "+dbname+".test Where `key`=?");
    			preparedStatement.setString(1, p.getFirst());
    			preparedStatement.executeQuery();
    		}
        	setReadTime(System.currentTimeMillis()- start);
    	}
    	
    	public void readDataOnTime() throws SQLException {
    		long start = System.currentTimeMillis();
    		Random randomGenerator = new Random();
    		for (TimedPair<String, Integer> p : points) {
    			PreparedStatement preparedStatement  = connect.prepareStatement("select * from "+dbname+".test Where ts>? AND ts<?");
    			preparedStatement.setTimestamp(1, new Timestamp(p.getTimeMillis()));
    			preparedStatement.setTimestamp(2, new Timestamp(p.getTimeMillis()+randomGenerator.nextInt(randTimeBound)*1000));
    			preparedStatement.executeQuery();
    		}
        	readTimeTIme =(System.currentTimeMillis()- start);
    	}

		@Override
		public long getWriteTime() {
			return writeTime;
		}

		@Override
		public void deleteDB() throws SQLException {
			PreparedStatement preparedStatement = connect.prepareStatement("Drop Database " + dbname);
			preparedStatement.executeUpdate();
			connect = null;
		}

		public long getReadTime() {
			return readTime;
		}

		private void setReadTime(long readTime) {
			this.readTime = readTime;
		}

		@Override
		public long getReadTimeTime() {
			return readTimeTIme;
		}

		@Override
		public long getDeleteTime() {
			return deleteTime;
		}
    	
    }
}



